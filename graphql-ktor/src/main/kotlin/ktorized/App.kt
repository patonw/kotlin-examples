/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package ktorized

import graphql.ExecutionInput.newExecutionInput
import graphql.GraphQL
import graphql.GraphQL.newGraphQL
import graphql.schema.idl.SchemaParser
import io.ktor.application.call
import io.ktor.application.install
import io.ktor.features.ContentNegotiation
import io.ktor.gson.gson
import io.ktor.http.content.defaultResource
import io.ktor.http.content.resources
import io.ktor.http.content.static
import io.ktor.request.receive
import io.ktor.response.respond
import io.ktor.routing.post
import io.ktor.routing.route
import io.ktor.routing.routing
import io.ktor.server.engine.embeddedServer
import io.ktor.server.netty.Netty

val schema = """
    type Query {
        apiVersion: String!
        serverInfo(id: Int! = 10): ServerInfo
    }

    type Mutation {
        addServer(name: String!, version: String!, peers: [Int!]!): ServerInfo!
    }

    type ServerInfo {
        name: String!
        version: String!
        peers: [ServerInfo!]!
    }
""".trimIndent()

/**
 * Data class for deserializing a GraphQL request
 *
 * @param operationName Optional. Convenient name to identify the query across client and server
 * @param query Static body of the query with uninterpolated placeholder variables
 * @param variables Concrete values for any placeholders in the query
 *
 * Any dynamic data in the request should be transmitted through variables. The client
 * should not interpolate user data into the query body itself.
 */
data class GraphiQLPostBody(val operationName: String?, val query: String, val variables: Map<String,Any>?)

/**
 * Extension method to execute a deserialized GraphQL request
 */
fun GraphQL.execute(req: GraphiQLPostBody) = with (newExecutionInput()) {
    query(req.query)
    req.operationName?.let { operationName(it) }
    req.variables?.let { variables(it) }
    execute(build())
}

/**
 * Create a Ktor webserver with a /graphql endpoint that encodes responses in JSON
 *
 * @param graphQL The GraphQL engine used to process queries
 * @param port TCP port to listen on
 */
fun makeWebServer(graphQL: GraphQL, port: Int = 8080) = embeddedServer(Netty, port = port) {
    install(ContentNegotiation) {
        gson {
            setPrettyPrinting()
            serializeNulls()
        }
    }
    routing {
        static("/") {
            resources("web")
            defaultResource("web/index.html")
        }
        route("graphql") {
            post {
                val req = call.receive<GraphiQLPostBody>()
                val result = graphQL.execute(req)

                call.respond(result.toSpecification())
            }
        }
    }
}

/**
 * Create a GraphQL engine that serves data from the mock database
 */
fun makeGraphQLEngine(): GraphQL {
    val registry = SchemaParser().parse(schema)

    // Bind lambdas to schema operations
    val wiredSchema = registry.wiring {
        val serverDB  = MockDB.connect() // Pretend connection is scoped only to this wiring

        type("Query") {
            it.dataFetcher("apiVersion") {
                "1.0.0"
            }
            it.dataFetcher("serverInfo") { env ->
                val id = env.getArgument<Int>("id")

                serverDB.fetch(id)
            }
        }

        type("Mutation") {
            // Adds a new server into the mock database
            it.dataFetcher("addServer") { env ->
                val args = env.arguments
                @Suppress("UNCHECKED_CAST") // strange... this is obviously a checked cast
                val peers = args["peers"] as? List<Int> ?: emptyList()
                val info = ServerInfo(args["name"] as String, args["version"] as String, peers)
                serverDB.insert(info)

                info
            }
        }

        // Resolvers for reference fields in ServerInfo
        type("ServerInfo") { resolve ->
            resolve.dataFetcher("version") { ctx ->
                val that = ctx.getSource() as ServerInfo
                that.version
            }

            resolve.dataFetcher("peers") { ctx ->
                val that = ctx.getSource() as ServerInfo
                that.peerIds.map { serverDB.fetch(it) }
            }
        }
    }

    return newGraphQL(wiredSchema).build()
}

fun main(args: Array<String>) {
    val graphQL = makeGraphQLEngine()
    val server = makeWebServer(graphQL)
    server.start(wait=true)
}
